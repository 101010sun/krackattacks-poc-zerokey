import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *
import subprocess
from .helper import logging
from .helper import packetProcess

#### Man-in-the-middle Code ####
class MitmSocket(L2Socket):
	def __init__(self, dumpfile=None, strict_echo_test=False, **kwargs):
		super(MitmSocket, self).__init__(**kwargs)
		self.pcap = None
		if dumpfile:
			self.pcap = PcapWriter("%s.%s.pcap" % (dumpfile, self.iface), append=False, sync=True)
		self.strict_echo_test = strict_echo_test

	def set_channel(self, channel):
		subprocess.check_output(["iw", self.iface, "set", "channel", str(channel)])

	def attach_filter(self, bpf):
		logging.log(logging.DEBUG, "Attaching filter to %s: <%s>" % (self.iface, bpf))
		attach_filter(self.ins, bpf, self.iface)

	def send(self, p):
		# 所有送出去的封包都要加 radiotap
		p[Dot11].FCfield |= 0x20
		L2Socket.send(self, RadioTap()/p)
		if self.pcap: self.pcap.write(RadioTap()/p)
		logging.log(logging.DEBUG, "%s: Injected frame %s" % (self.iface, packetProcess.dot11_to_str(p)))

	def _strip_fcs(self, p):
		# radiotap header flags 0x00...0: no used FCS failed
		# .present is flagsfield
		if p[RadioTap].present & 2 != 0:
			rawframe = str(p[RadioTap])
			pos = 8 # FCS 在 frame 開頭後第 9 bytes 的地方
			while ord(rawframe[pos - 1]) & 0x80 != 0: pos += 4
			# If the TSFT field is present, it must be 8-bytes aligned
			if p[RadioTap].present & 1 != 0:
				pos += (8 - (pos % 8))
				pos += 8
			# 如果要解析 MPDU 訊息，必須要把 radiotap flag 的部分，然後 & 0x10
			if ord(rawframe[pos]) & 0x10 != 0:
				return Dot11(str(p[Dot11])[:-4])
		return p[Dot11]

	def recv(self, x=MTU):
		p = L2Socket.recv(self, x)
		if p == None: 
			return None
		if p.getlayer(Dot11) == None:
			return None
		# if self.pcap: self.pcap.write(p)
		# Don't care about control frames
		if p.type == 1:
			logging.log(logging.ALL, "%s: ignoring control frame %s" % (self.iface, packetProcess.dot11_to_str(p)))
			return None

		# 1. Radiotap monitor mode header is defined in ieee80211_add_tx_radiotap_header: TX_FLAGS, DATA_RETRIES, [RATE, MCS, VHT, ]
		# 2. Radiotap header for normal received frames is defined in ieee80211_add_rx_radiotap_header: FLAGS, CHANNEL, RX_FLAGS, [...]
		# 3. Beacons generated by hostapd and recieved on virtual interface: TX_FLAGS, DATA_RETRIES
		#
		# Conclusion: if channel flag is not present, but rate flag is included, then this could be an echoed injected frame.
		# Warning: this check fails to detect injected frames captured by the other interface (due to proximity of transmittors and capture effect)
		radiotap_possible_injection = (p[RadioTap].present & logging.IEEE80211_RADIOTAP_CHANNEL == 0) and not (p[RadioTap].present & logging.IEEE80211_RADIOTAP_RATE == 0)

		# Hack: ignore frames that we just injected and are echoed back by the kernel. Note that the More Data flag also
		#	allows us to detect cross-channel frames (received due to proximity of transmissors on different channel)
		if p[Dot11].FCfield & 0x20 != 0 and (not self.strict_echo_test or radiotap_possible_injection):
			logging.log(logging.DEBUG, "%s: ignoring echoed frame %s (0x%02d, present=%08d, strict=%d)" % (self.iface, packetProcess.dot11_to_str(p), p[Dot11].FCfield, p[RadioTap].present, radiotap_possible_injection))
			return None
		else:
			logging.log(logging.ALL, "%s: Received frame: %s" % (self.iface, packetProcess.dot11_to_str(p)))

		# FIXME: Strip the FCS if present, and drop the RadioTap header, will make package wrong?
		return self._strip_fcs(p)

	def close(self):
		# if self.pcap: self.pcap.close()
		super(MitmSocket, self).close()
